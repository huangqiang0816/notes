# 浏览起渲染原理

- 进程 `Process`
> 多个程序当成时进程

- 线程 `Thread`
> 每个程序做多个事情 就是线程
> 单线程

- 栈内存 `Stack`
> 提供一个环境来执行代码的

- 堆内存

## 浏览器拿到代码后的执行

- 浏览器再内存中开辟一块内存，用来给代码的执行提供环境，同时分配一个主线程去解析和执行代码。

- 进栈执行 执行完出栈（当前代码执行的时候、主线程被占用，执行完就出栈）

```html
  <link href="1.css" />
  <link href="2.css" />
```

 当浏览器等遇到`link/script/img`等需要加载外部资源的时候、浏览器会开辟全新的线程去加载文件

 `js 单线程、浏览器多线程`

Task QUEUE 任务队列
任务1：请求1.css
任务2：请求2.css
... 

- js 主线程继续执行

- 自上而下走完后、只生产Dom Tree,外部资源并不会立即返回来、现在并不会渲染出页面

- Event loop 事件循环（微任务，宏任务）

- 去任务队列（Task QUEUE）里找请求完的资源放到主线程里去执行

> 拿到css后 -> CSSOM
> DOM Tree + CSSOM  -> render Tree
> 开始绘制 通知 GPU 去渲染


## 基本流程

1. 解析html 生产DOM树，解析css,生产CSSOM树

2. 将DOM树和CSSOM 树组合、生成渲染树（Render Tree）

3. layout(回流) 根据生成的渲染树，计算他们在设备视口（viewport）内的确切位置和大小、这个计算的阶段就是回流。

4. Painting(重绘)根据渲染树以及回流得到的几个信息、得到节点的绝对像素

5. Display 将像素发送给GPU,展示在页面上

- 可以优化的点
1. 资源的合并压缩、减少请求数量和请求资源大小
2. 图片懒加载、等主页面加载完后再做图片的处理
